라이브러리와 프레임워크의 차이
주도권이 개발자에게 있다: 라이브러리
- 주도권을 개발자가 가짐
- 쓰고싶은 기술, 쓰고 싶은 도구를 마음대로
주도권이 개발자에게 없다 : 프레임워크
- 프레임워크가 허용하는 범위 내에서 써야함
- 큰틀은 정해져있음




//사전 렌더링(Pre Rendering) Next의 핵심
/**
 * 브라우저의 요청에 사전에 렌더링이 완료된 HTML을 응답하는 렌더링 방식
 * client sIde rendering의 단점을 효율적으로 해결하는 기술
 * 
 * csr은 초기 접속 이후가 빠름 
 * First Contentful Paint - FCP
 * "요청 시작" 시점으로부터 컨텐츠가 화면에 처음 나타나는데 걸리는 시간
 * 리액트가 이게 느렸음
 * 
 * 그래서 등장한 NEXT.JS의 사전 렌더링
 * 서버에게 초기 요청을 보내면 서버가 JS코드를 직접 실행을 시켜서 렌더링 우리가 만든
 * 모든 컴포넌트들을 html을 렌더링 시키고
 * 그대로 브라우저 HTML을 보냄 그리고 브라우저는 유저에게 html을 렌더링
 * 그리고 바로 서버는 후속으로 바로 js bundle 코드를 브라우저로 보내 브라우저는 js를 html과 연결 
 * 그 다음 유저한테 보냄
 * 
 * 처음에는 화면만 먼저 보내고 후속으르 js를 보내 브라우저에서 연결 후 상호작용이 가능한 페이지를 만들고 유저한테 보냄
 * 여기서 html과 js를 연결해주는 것을 수화(Hydration)이라 함
 * 
 * 
 * 
 * 마지막으로 상호작용까지 가능한 상태를 tti라고 함
 * time to interective
 * 
 * 
 * 
 * 그러면 페이지 이동 요청은
 * 클라이언트 사이드 렌더링 방식으로 처리
 * 페이지 이동 요청을 하면 클라이언트 브라우저가 컴포넌트 교체 후
 * 페이지 교체한 걸 다시 유저한테 보냄
 */



서버 컴포넌트 등장배경
사전렌더링 후 서버에서 js 번들을 만들어서 클라이언트를 거쳐 유저에게 주는데 하이드레이션이 필요없는 컴포넌트들까지 js번들에
포함해서 용량이 너무커짐
그래서 등장한게 서버컴포넌트

서버 컴포넌트는
서버측에서 사전 렌더링 즉 프리 렌더링을 진행할 때 딱 한번만 실행 됨

클라이언트 컴포넌트
사전 렌더링 한번,
하이드레이션 후 한번 총 2번 실행
서버와 클라이언트에서 모두 실행



Co-Location: 앱라우터에서 page.tsx 등등 이런 지시어 아니면 일반 자바스크립트로 인식
그래서 특정 페이지 안에서만 사용하는 컴포넌트는 app 폴더 안에 만들어도 좋을듯


서버 컴포넌트 주의사항
1. 서버 컴포넌트에는 브라우저에서 실행될 코드가 포함x
2. 클라이언트 컴포넌트는 클라이언트에서만 실행
3. 클라이언트 컴포넌트에서 서버 컴포넌트 import 할 수 없다
    - 브라우저에서 하이드레이션 할 때 실행을 하면 서버 컴포넌트는 없다. 서버 컴포넌트는 자바스크립트 번들에서 부터 제외 
    - 그니깐 하이드레이션 할 때 없겠지?
    - 이럴 경우 next.js에는 자동으로 서버 컴포넌트를 클라이언트 컴포넌로 변환 "use client" 없을 때
4. 서버 컴포넌트에서 클라이언트 컴포넌트에게 직렬화 되지 않는 Props는 전달 불가
        - 직렬화 (Serialization) - 객체, 배열, 클래스 등의 복잡한 구조의 데이터를 네트워크 상으로 전송하기 위해
                                 아주 단순한 형태(문자열, Byte)로 변환하는 것
                                 함수는 직렬화 불가능 그래서 함수 같은 거는 서버 컴포넌트에서 클라이언트 컴포넌트에 
                                 props로 전달 불가

시전 렌더링 때
엄밀히 따지면 서버 컴포넌트가 먼저 렌더링하고 RSC Payload 진행
즉 리액트 서버 컴포넌트 직렬화를 시작한다 그다음 클라이언트 컴포넌트를 실행하고 HTML  페이지 생성
    그안에는
    - 서버 컴포넌트의 렌더링 결과
    - 연결된 클라이언트 컴포넌트의 위치
    - 클라이언트 컴포넌트에게 전달하는 Props 값



Pre Fetching 프리페칭 - 이동할 페이지의 데이터를 미리 불어오는 기능
초기 접속 요청이 끝난 후 유저가 페이지를 이동할 때 브라우저가 처리 하고 서버에서 데이터를 받아오는데 불러운 페이지에서 다른 페이지를 불러오고 이동이
가능한 페이지들 데이터를 미리 불러 올 수 있게 하는 것을 프리페칭이라 하고 앱 라우터는 서버에서 js 번들뿐만 아니라 Rsc Payload도
같이 준다


next에서는
yarn build 즉 빌드하고
yarn start로 프로덕션 모드로 실행 가능


기존 페이지 라우터에서는
getSeverSideProps같은 서버 전용 함수를 사용해서 데이터 페칭을 사전 렌더링중에 했고
이런 함수들을 써서 서버에서만 작동하게 했다.
그래서 최상위 컴포넌트에서 선언을 할 수 밖에 없고
계속해서 프롭스 드릴링이나 아니면 컨텍스트api로 했어야 했다. 그런데 이제
앱라우터에서 안써도 됩니다.


앱라우터에서 서버 컴포넌트에서 async 키워드를 붙여
await fetch를 사용해 서버컴포넌트 + 비동기 함수로 만들 수 있다.

클라이언트에서 async는 prop 같은 문제가 있어서 못씀


공식문서에서!
데이터가 필요한 곳에서 직접 불러와라 라고 작성함





데이터 캐시
fetch 메서드를 활용해 불러온 데이터를 Next 서버에서 보관하는 기능
영구적으로 데이터를 보관하거나, 특정 시간을 주기로 갱신 시키는 것도 가능
불 필요한 데이터 요청의 수를 줄여서 웹 서비스의 성능을 크게 개선할 수 있음

getFetchRequest 이거 확인





Request Memoization 요청을 기억한다.
하나의 페이지에서 API 중복 요청을 자동으로 제거해주고 최적화 해주는 것
첫번째 요청응답 데이터 캐시에 케싱한다, 리퀘스트 메모이제이션에 캐싱한다
그다음 똑같은 것을 요청하면 리퀘스트 메모이제이션에 있는 지 검사를 해서 있으면 데이터 캐시에 저장 조회를 하지 않고 
리퀘스트 메모이제이션에 있는지 확인하고 리퀘스트 메이제이션에서 보낸다.
그러면 데이터 캐싱하는 거랑 뭔 차이임?
예는 하나의 페이지를 렌더링 하는 동안에 중복된 api 요청을 캐싱하기 위해 존재하는 거임
렌더링이 종료되면 모든 캐시가 소멸된다.



데이터 캐시는 백엔드 서버로부터 불어온 데이터를 거의 영구적으로 보관하기 위해 사용된다
서버 가동중에는 영구적으로 보관된다. 그러니 Request Memoization랑은 다르다

그런데 Request Memoization 이거 왜 도입하나? 그냥 중복 요청을 안보내면 되는 거 아닌가?
= 서버 컴포넌트 때문에
page 라우터에서는 서버 사이드 함수를 사용하려면 페이지 최상단에서 선언해서 프롭스 드릴링 하거나
contextApi를 사용했어야 했는데 앱라우터 서버컴포넌트는 필요한 컴포넌트에서 서버 사이드 작업을 할 수 있어서 아무리 복잡한
컴포넌트 구조여도 효율적으로 관리가 가능하다 그러나 단점이 컴포넌트 별로 서버 요청을 하면 증복된 서버 요청이 있는데
한 페이지에서 중복된 API를 최적화 해준다 똑같은 거 2개 이상 호출하면 1번만 한다.
이거는 자동으로 동작




풀 라우트 캐시
NEXT 서버측에서 빌드 타임에 특정 페이지의 렌더링 결과를 캐싱하는 기능
어떠한 페이지가 빌트 타임에 캐싱을 할까?
Static Page 정적 페이지는 자동으로 풀 라우트 캐시가 이루어지고
Dynamic Page 아닌 것들이 Static Page

Dynamic Page로 설정된 기준
특정 페이지가 접속 요청을 받을 때 마다 매번 변화가 생기거나, 데이터가 달라지는 경우

1. 서버컴포너트가 캐시되지 않은 Data Fetching을 할 경우(클라이언트 컴포넌트는 페이지 유형에 영향을 안 끼침)
2. 동적함수(쿠키, 헤더, 쿼리스트링)을 사용하는 컴포넌트가 있을 때


Dynamic Page는 폴 라우트 캐시만 안될 뿐 리퀘스트 메모이제이션이나 데이터 캐시는 작동을 한다.

풀 라우트 캐시는
특정 시간이 지나면 재갱신도 가능함
fetch에 
next: {revalidate: 3} 같은 특정 시간 지나면 캐시 재갱신 하는게 있다면 폴 라우트 캐시도 저 시간이 지나면 재갱신함 왜? 데이터 캐시도 상하면 폴라우트 캐시도 상한다.




클라이언트 라우터 캐시
블라우저에 저장되는 캐시
페이지 이동을 효율적으로 진행하기 위해 페이지의 일부 데이터를 보관함
서버에 요청할 때 마다 layout을 계속 호출할거야?


브라우저 클라이언트에 클라이언트 라우터 캐시라는 저장 공간에
루트레이아웃
서치바 레이아웃 이러한 레이아웃 것들을 클라이언트 라우터 캐시에 저장하고 끌어다 씀





스트리밍이란?
- 스트리밍이란 서버에서 클라이언트로 데이터를 넘겨줄 때 데이터가 너무 크거나
아니면 서버측에서 데이터를 준비하는 시간이 오래 걸려서 데이터를 빠르게 전송하기 힘들 때
마치 강물에 흐르는 듯 짤라서 보내는 걸 스트리밍이란 개천, 하천 같은 거
next에서 자체적으로 제공
- 사용자가 특정 페이지에 접속했을 때 먼저 단순한 컴포넌들 부터 보여주고
데이타 통신을 하는 오래 걸리는 것들은 일단 로딩을 보여주고 서버에서 컴포넌트 랜더링이 끝나면
나중에 교체해준다.


페이지 스트리밍
오래 걸리는 컴포넌트의 렌더링을
사용자가 좀 더 좋은 환경에서 기다릴 수 있도록
빨리 렌더링 할 수 있는 컴포넌트들을 밑반찬 처럼 내주는 것






서버 액션이란?
브라우저에서 호출할 수 있는 서버에서 실행되는 비동기 함수